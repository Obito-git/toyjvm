// TODO: for now it is a stub, mostly generated by AI

use crate::{ClassId, HeapAddr, Value};

pub enum HeapObject {
    Instance {
        class_id: ClassId,
        fields: Vec<Value>,
    },
    JavaString {
        utf8: String,
    },
    JavaArray {
        len: usize,
        elements: Vec<Value>,
    },
}

/// https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-2.html#jvms-2.5.3
pub struct Heap {
    objects: Vec<HeapObject>,
}

impl Heap {
    pub fn new() -> Self {
        Self {
            objects: Vec::new(),
        }
    }

    fn push(&mut self, obj: HeapObject) -> HeapAddr {
        let idx = self.objects.len();
        self.objects.push(obj);
        idx
    }

    pub fn alloc_instance(&mut self, class_id: ClassId, field_count: usize) -> HeapAddr {
        self.push(HeapObject::Instance {
            class_id,
            fields: vec![Value::Null; field_count],
        })
    }

    pub fn alloc_string<S: Into<String>>(&mut self, s: S) -> HeapAddr {
        self.push(HeapObject::JavaString { utf8: s.into() })
    }

    pub fn alloc_array_refs(&mut self, len: usize) -> HeapAddr {
        self.push(HeapObject::JavaArray {
            len,
            elements: vec![Value::Null; len],
        })
    }

    pub fn get(&self, h: HeapAddr) -> &HeapObject {
        self.objects.get(h).expect("heap: invalid handle (get)")
    }

    pub fn get_mut(&mut self, h: HeapAddr) -> &mut HeapObject {
        self.objects
            .get_mut(h)
            .expect("heap: invalid handle (get_mut)")
    }

    pub fn write_instance_field(&mut self, h: HeapAddr, slot: usize, val: Value) {
        match self.get_mut(h) {
            HeapObject::Instance { fields, .. } => {
                let cell = fields.get_mut(slot).expect("heap: instance field slot OOB");
                *cell = val;
            }
            _ => panic!("heap: write_instance_field on non-instance"),
        }
    }

    pub fn read_instance_field(&self, h: HeapAddr, slot: usize) -> Value {
        match self.get(h) {
            HeapObject::Instance { fields, .. } => fields
                .get(slot)
                .expect("heap: instance field slot OOB")
                .clone(),
            _ => panic!("heap: read_instance_field on non-instance"),
        }
    }

    pub fn array_len(&self, h: HeapAddr) -> usize {
        match self.get(h) {
            HeapObject::JavaArray { len, .. } => *len,
            _ => panic!("heap: array_len on non-array"),
        }
    }

    pub fn array_get(&self, h: HeapAddr, idx: usize) -> Value {
        match self.get(h) {
            HeapObject::JavaArray { elements, .. } => {
                elements.get(idx).expect("heap: array_get OOB").clone()
            }
            _ => panic!("heap: array_get on non-array"),
        }
    }

    pub fn array_set(&mut self, h: HeapAddr, idx: usize, val: Value) {
        match self.get_mut(h) {
            HeapObject::JavaArray { elements, .. } => {
                *elements.get_mut(idx).expect("heap: array_set OOB") = val;
            }
            _ => panic!("heap: array_set on non-array"),
        }
    }
}
